import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import { getDefaultDomain } from '@antv/l7-utils';
import BaseModel from "../../core/BaseModel";
import { ShaderLocation } from "../../core/CommonStyleAttribute";
import { RasterImageTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/raster/raster_2d_frag.glsl' */
const rasterFrag = "layout(std140) uniform commonUniforms {\n  vec2 u_domain;\n  float u_opacity;\n  float u_noDataValue;\n  float u_clampLow;\n  float u_clampHigh;\n};\n\nuniform sampler2D u_rasterTexture;\nuniform sampler2D u_colorTexture;\n\nin vec2 v_texCoord;\n\nbool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? x != x : x != 0.0; }\n\nout vec4 outputColor;\n\nvoid main() {\n  // Can use any component here since u_rasterTexture is under luminance format.\n  float value = texture(SAMPLER_2D(u_rasterTexture), vec2(v_texCoord.x, v_texCoord.y)).r;\n  if (value == u_noDataValue || isnan_emu(value)) {\n    discard;\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\n    discard;\n  } else {\n    float normalisedValue =(value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n    vec4 color = texture(SAMPLER_2D(u_colorTexture), vec2(normalisedValue, 0));\n    \n    outputColor = color;\n    outputColor.a = outputColor.a * u_opacity ;\n    if (outputColor.a < 0.01)\n      discard;\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/raster/raster_2d_vert.glsl' */
const rasterVert = "\nlayout(location = 0) in vec3 a_Position;\nlayout(location = 14) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_domain;\n  float u_opacity;\n  float u_noDataValue;\n  float u_clampLow;\n  float u_clampHigh;\n};\n\nout vec2 v_texCoord;\n\n#pragma include \"projection\"\n\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy,0., 1.0));\n}\n";
export default class RasterModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "colorTexture", void 0);
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      clampLow = true,
      clampHigh = true,
      noDataValue = -9999999,
      domain,
      rampColors
    } = this.layer.getLayerConfig();
    const newdomain = domain || getDefaultDomain(rampColors);
    this.colorTexture = this.layer.textureService.getColorTexture(rampColors, newdomain);
    const commonOptions = {
      u_domain: newdomain,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_clampLow: clampLow ? 1 : 0,
      u_clampHigh: (typeof clampHigh !== 'undefined' ? clampHigh : clampLow) ? 1 : 0,
      u_rasterTexture: this.texture,
      u_colorTexture: this.colorTexture
    };
    this.textures = [this.texture, this.colorTexture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getRasterData(parserDataItem) {
    return _asyncToGenerator(function* () {
      if (Array.isArray(parserDataItem.data)) {
        // 直接传入波段数据
        return {
          data: parserDataItem.data,
          width: parserDataItem.width,
          height: parserDataItem.height
        };
      } else {
        // 多波段形式、需要进行处理
        const {
          rasterData,
          width,
          height
        } = yield parserDataItem.data;
        return {
          data: Array.from(rasterData),
          width,
          height
        };
      }
    })();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const source = _this2.layer.getSource();
      const {
        createTexture2D,
        queryVerdorInfo
      } = _this2.rendererService;
      const parserDataItem = source.data.dataArray[0];
      const {
        data,
        width,
        height
      } = yield _this2.getRasterData(parserDataItem);
      _this2.texture = createTexture2D({
        // @ts-ignore
        data: new Float32Array(data),
        width,
        height,
        /**
         * WebGL1 allow the combination of gl.LUMINANCE & gl.FLOAT with OES_texture_float
         */
        format: queryVerdorInfo() === 'WebGL1' ? gl.LUMINANCE : gl.RED,
        type: gl.FLOAT,
        alignment: 1
      });
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'rasterImageData',
        vertexShader: rasterVert,
        fragmentShader: rasterFrag,
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture, _this$colorTexture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
    (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 || _this$colorTexture.destroy();
  }
  registerBuiltinAttributes() {
    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: ShaderLocation.UV,
        name: 'a_Uv',
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}