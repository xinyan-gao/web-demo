import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { HeatmapGridTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/grid/grid_frag.glsl' */
const grid_frag = "in vec4 v_color;\n\n#pragma include \"scene_uniforms\"\n#pragma include \"picking\"\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/grid/grid_vert.glsl' */
const grid_vert = "layout(location = 0) in vec3 a_Position;\r\nlayout(location = 1) in vec4 a_Color;\r\nlayout(location = 10) in vec3 a_Pos;\r\n\r\nlayout(std140) uniform commonUniforms {\r\n    vec2 u_radius;\r\n    float u_opacity;\r\n    float u_coverage;\r\n    float u_angle;\r\n};\r\n\r\n\r\nout vec4 v_color;\r\n\r\n\r\n#pragma include \"projection\"\r\n#pragma include \"project\"\r\n#pragma include \"picking\"\r\n\r\nvoid main() {\r\n  v_color = a_Color;\r\n  v_color.a *= u_opacity;\r\n\r\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\r\n  vec2 offset = a_Position.xy * u_radius * rotationMatrix * u_coverage ;\r\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n  // gl_Position = project_common_position_to_clipspace(project_pos);\r\n\r\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\r\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec2 customLnglat = customProject(lnglat) - u_sceneCenterMercator; // \u5C06\u7ECF\u7EAC\u5EA6\u8F6C\u6362\u4E3A\u9AD8\u5FB72.0\u9700\u8981\u7684\u5E73\u9762\u5750\u6807\r\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\r\n    gl_Position = u_Mvp * (project_pos);\r\n  } else {\r\n     vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n    gl_Position = project_common_position_to_clipspace(project_pos);\r\n  }\r\n\r\n  setPickingColor(a_PickingColor);\r\n}\r\n";
export default class GridModel extends BaseModel {
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      coverage,
      angle
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset],
      u_opacity: opacity || 1.0,
      u_coverage: coverage || 0.9,
      u_angle: angle || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'heatmapGrid',
        vertexShader: grid_vert,
        fragmentShader: grid_frag,
        triangulation: HeatmapGridTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: 'pos',
      // 顶点经纬度位置
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: 10,
        name: 'a_Pos',
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: feature => {
          const coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;
          return [coordinates[0], coordinates[1], 0];
        }
      }
    });
  }
}