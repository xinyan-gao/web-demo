import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { FlowLineTriangulation } from "../../core/line_trangluation";
/* babel-plugin-inline-import '../shaders/flow/flow_line_frag.glsl' */
const flow_line_frag = "// #extension GL_OES_standard_derivatives : enable\n\nin vec4 v_color;\nout vec4 outputColor;\n\n\n// line texture\n\n#pragma include \"picking\"\n\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n"; // linear simple line shader
import { ShaderLocation } from "../../core/CommonStyleAttribute";
/* babel-plugin-inline-import '../shaders/flow/flow_line_vert.glsl' */
const flow_line_vert = "layout(location = 0) in vec3 a_Position;\nlayout(location = 1) in vec4 a_Color;\nlayout(location = 9) in vec2 a_Size;\nlayout(location = 12) in vec4 a_Instance;\nlayout(location = 13) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniorm {\n  float u_gap_width: 1.0;\n  float u_stroke_width: 1.0;\n  float u_stroke_opacity: 1.0;\n};\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nout vec4 v_color;\n\nvec2 project_pixel_offset(vec2 offsets) {\n\n   vec2 data = project_pixel(offsets);\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // P20_2 \u5750\u6807\u7CFB\u4E0B\uFF0C\u4E3A\u4E86\u548C Web \u58A8\u5361\u6258\u5750\u6807\u7CFB\u7EDF\u4E00\uFF0Czoom \u9ED8\u8BA4\u51CF3\n    return data;\n  }\n\n  return vec2(data.x, -data.y);;\n}\n\nvec2 line_dir(vec2 target, vec2 source) {\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // P20_2 \u5750\u6807\u7CFB\u4E0B\uFF0C\u4E3A\u4E86\u548C Web \u58A8\u5361\u6258\u5750\u6807\u7CFB\u7EDF\u4E00\uFF0Czoom \u9ED8\u8BA4\u51CF3\n     return normalize(target - source);\n  }\n  return normalize(ProjectFlat(target) - ProjectFlat(source));\n}\n\nfloat flag_gap() {\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // P20_2 \u5750\u6807\u7CFB\u4E0B\uFF0C\u4E3A\u4E86\u548C Web \u58A8\u5361\u6258\u5750\u6807\u7CFB\u7EDF\u4E00\uFF0Czoom \u9ED8\u8BA4\u51CF3\n     return 1.;\n  }\n  return -1.;\n\n}\n\n\nvoid main() {\n\n// \u900F\u660E\u5EA6\u8BA1\u7B97\n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n  vec2 flowlineDir = line_dir(target,source);\n  vec2 perpendicularDir = vec2(-flowlineDir.y, flowlineDir.x); // mapbox || \u9AD8\u5FB7\n   \n  vec2 position = mix(source, target, a_Position.x);\n  \n  float lengthCommon = length(project_position(vec4(target,0,1)) - project_position(vec4(source,0,1)));  //    \n  vec2 offsetDistances = a_Size.x * project_pixel_offset(vec2(a_Position.y, a_Position.z)); // Mapbox || \u9AD8\u5FB7\n  vec2 limitedOffsetDistances = clamp(   \n   offsetDistances,\n   project_pixel(-lengthCommon*.2), project_pixel(lengthCommon*.2)\n  );\n\n\n  float startOffsetCommon = project_pixel(offsets[0]);\n  float endOffsetCommon = project_pixel(offsets[1]);\n  float endpointOffset = mix(\n    clamp(startOffsetCommon, 0.0, lengthCommon*.2),\n    -clamp(endOffsetCommon, 0.0, lengthCommon*.2),\n    a_Position.x\n  );\n\n  vec2 normalsCommon =  u_stroke_width * project_pixel_offset(vec2(a_Normal.x, a_Normal.y)); // mapbox || \u9AD8\u5FB7\n\n  float gapCommon = flag_gap() * project_pixel(u_gap_width);\n  vec3 offsetCommon = vec3(\n    flowlineDir * (limitedOffsetDistances[1] + normalsCommon.y + endpointOffset * 1.05) -\n    perpendicularDir *  (limitedOffsetDistances[0] + gapCommon + normalsCommon.x),\n    0.0\n  );\n\n  vec4 project_pos = project_position(vec4(position.xy, 0, 1.0));\n\n  vec4 fillColor = vec4(a_Color.rgb, a_Color.a * opacity);\n  v_color = mix(fillColor, vec4(u_stroke.xyz, u_stroke.w * fillColor.w * u_stroke_opacity), a_Normal.z);\n\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy +  offsetCommon.xy, 0., 1.0));\n\n\n\n  setPickingColor(a_PickingColor);\n}\n";
export default class FlowLineModel extends BaseModel {
  getCommonUniformsInfo() {
    const {
      gapWidth = 2,
      strokeWidth = 1,
      strokeOpacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_gap_width: gapWidth,
      u_stroke_width: strokeWidth,
      u_stroke_opacity: strokeOpacity
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const modelFill = yield _this2.layer.buildLayerModel({
        moduleName: 'flow_line',
        vertexShader: flow_line_vert,
        fragmentShader: flow_line_frag,
        inject: _this2.getInject(),
        triangulation: FlowLineTriangulation,
        styleOption: _this2.layer.getLayerConfig().symbol,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [modelFill];
    })();
  }
  registerBuiltinAttributes() {
    // 注册 Style 参与数据映射的内置属性
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        // 宽度
        shaderLocation: ShaderLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'instance',
      // 弧线起始点信息
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Instance',
        shaderLocation: 12,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: ShaderLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
  }
}