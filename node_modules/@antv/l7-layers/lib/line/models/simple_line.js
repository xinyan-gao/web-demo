"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _CommonStyleAttribute = require("../../core/CommonStyleAttribute");
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/simple/simpleline_frag.glsl' */
const simple_line_frag = "\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\nin float v_distanceScale;\nin vec4 v_color;\n//dash\nin vec4 v_dash_array;\n\nout vec4 outputColor;\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_distanceScale, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      // \u865A\u7EBF\u90E8\u5206\n      discard;\n    };\n  }\n  if(u_linearColor==1.0){\n    outputColor = mix(u_sourceColor, u_targetColor, v_distanceScale);\n    outputColor.a *= v_color.a; // \u5168\u5C40\u900F\u660E\u5EA6\n  }\n  else{\n    outputColor = v_color;\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/simple/simpleline_vert.glsl' */
const simple_line_vert = "layout(location = 0) in vec3 a_Position;\nlayout(location = 1) in vec4 a_Color;\nlayout(location = 9) in vec4 a_SizeDistanceAndTotalDistance;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nout vec4 v_color;\nout float v_distanceScale;\nout vec4 v_dash_array;\n\nvoid main() {\n  //dash\u8F93\u51FA\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_SizeDistanceAndTotalDistance.a;\n\n  v_color = a_Color; \n  v_distanceScale = a_SizeDistanceAndTotalDistance.b / a_SizeDistanceAndTotalDistance.a;\n  v_color.a = v_color.a * opacity;\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy, project_pixel(a_SizeDistanceAndTotalDistance.y) + h * 0.2, 1.0));\n  } else {\n    float lineHeight = a_SizeDistanceAndTotalDistance.y;\n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      h *= 2.0/pow(2.0, 20.0 - u_Zoom);\n    }\n\n    // amap1.x\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      lineHeight *= pow(2.0, 20.0 - u_Zoom);\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, lineHeight + h, 1.0));\n    gl_PointSize = 10.0;\n  }\n}\n";
class SimpleLineModel extends _BaseModel.default {
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      lineType = 'solid',
      dashArray = [10, 5, 0, 0],
      vertexHeightScale = 20.0
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== 'dash') {
      u_dash_array = [0, 0, 0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    // 转化渐变色
    let useLinearColor = 0; // 默认不生效
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = (0, _l7Utils.rgb2arr)(sourceColor);
      targetColorArr = (0, _l7Utils.rgb2arr)(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_dash_array,
      // 顶点高度 scale
      u_vertexScale: vertexHeightScale,
      // 渐变色支持参数
      u_linearColor: useLinearColor
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      return _this.buildModels();
    })();
  }
  getShaders() {
    return {
      frag: simple_line_frag,
      vert: simple_line_vert,
      type: 'lineSimpleNormal'
    };
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this2.initUniformsBuffer();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _triangulation.SimpleLineTriangulation,
        inject: _this2.getInject(),
        primitive: _l7Core.gl.LINES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // this.styleAttributeService.registerStyleAttribute({
    //   name: 'distance',
    //   type: AttributeType.Attribute,
    //   descriptor: {
    //     name: 'a_Distance',
    //     shaderLocation: 14,
    //     buffer: {
    //       // give the WebGL driver a hint that this buffer may change
    //       usage: gl.STATIC_DRAW,
    //       data: [],
    //       type: gl.FLOAT,
    //     },
    //     size: 1,
    //     update: (
    //       feature: IEncodeFeature,
    //       featureIdx: number,
    //       vertex: number[],
    //     ) => {
    //       return [vertex[3]];
    //     },
    //   },
    // });
    // this.styleAttributeService.registerStyleAttribute({
    //   name: 'total_distance',
    //   type: AttributeType.Attribute,
    //   descriptor: {
    //     name: 'a_Total_Distance',
    //     shaderLocation: 13,//枚举不够了,先固定写值吧,在shader中location也成一致的并且不与其他的重复就行了
    //     buffer: {
    //       // give the WebGL driver a hint that this buffer may change
    //       usage: gl.STATIC_DRAW,
    //       data: [],
    //       type: gl.FLOAT,
    //     },
    //     size: 1,
    //     update: (
    //       feature: IEncodeFeature,
    //       featureIdx: number,
    //       vertex: number[],
    //     ) => {
    //       return [vertex[5]];
    //     },
    //   },
    // });
    //size.x,size,y,distance,totalDistance
    this.styleAttributeService.registerStyleAttribute({
      name: 'sizeDistanceAndTotalDistance',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_SizeDistanceAndTotalDistance',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.SIZE,
        buffer: {
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          const {
            size = 1
          } = feature;
          const a_Size = Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          return [a_Size[0], a_Size[1], vertex[3], vertex[5]];
        }
      }
    });
  }
}
exports.default = SimpleLineModel;