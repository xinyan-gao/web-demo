"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _CommonStyleAttribute = require("../../core/CommonStyleAttribute");
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/image/image_frag.glsl' */
const pointImageFrag = "layout(std140) uniform commonUniforms {\n  vec2 u_textSize;\n  float u_raisingHeight;\n  float u_heightfixed;\n};\n\nuniform sampler2D u_texture;\n\nin vec4 v_color;\nin vec2 v_uv;\nin float v_opacity;\n\n#pragma include \"picking\"\n\nout vec4 outputColor;\n\nvoid main(){\n  vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n  vec4 textureColor;\n\n  // Y = 0.299R + 0.587G + 0.114B // \u4EAE\u5EA6\u63D0\u53D6\n  \n  textureColor = texture(SAMPLER_2D(u_texture), pos);\n\n  // Tip: \u53BB\u9664\u8FB9\u7F18\u90E8\u5206 mipmap \u5BFC\u81F4\u7684\u6DF7\u5408\u53D8\u6697\n  float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n  if(fragmengTocenter >= 0.5) {\n        float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n        textureColor.a *= luma;\n  }\n  \n  if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n        outputColor= textureColor;\n  }else {\n        outputColor= step(0.01, textureColor.z) * v_color;\n  }\n  outputColor.a *= v_opacity;\n  if (outputColor.a < 0.01) {\n      discard;\n  }\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/image/image_vert.glsl' */
const pointImageVert = "layout(location = 0) in vec3 a_Position;\nlayout(location = 1) in vec4 a_Color;\nlayout(location = 9) in float a_Size;\nlayout(location = 14) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_textSize;\n  float u_raisingHeight;\n  float u_heightfixed;\n};\n\nout vec4 v_color;\nout vec2 v_uv;\nout float v_opacity;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  v_color = a_Color;\n  v_opacity = opacity;\n  v_uv = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  vec2 offset = project_pixel(offsets);\n\n  float raisingHeight = u_raisingHeight;\n  if(u_heightfixed < 1.0) { // false\n    raisingHeight = project_pixel(u_raisingHeight);\n  } else {\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      raisingHeight = u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy + offset, raisingHeight, 1.0));\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n";
class ImageModel extends _BaseModel.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas(),
          mag: 'linear',
          min: 'linear mipmap nearest',
          mipmap: true
        });
        // 更新完纹理后在更新的图层的时候需要更新所有的图层
        // this.layer.layerModelNeedUpdate = true;
        setTimeout(() => {
          // 延迟渲染
          this.layerService.throttleRenderLayers();
        });
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: _l7Core.gl.LINEAR,
        min: _l7Core.gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128,
        mipmap: true
      });
    });
  }
  getUninforms() {
    // ThreeJS 图层兼容
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonInfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonInfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0,
      heightfixed = false
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_raisingHeight: Number(raisingHeight),
      u_heightfixed: Number(heightfixed),
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.iconService.on('imageUpdate', _this.updateTexture);
      _this.updateTexture();
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off('imageUpdate', this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'pointImage',
        vertexShader: pointImageVert,
        fragmentShader: pointImageFrag,
        triangulation: _triangulation.PointImageTriangulation,
        inject: _this2.getInject(),
        depth: {
          enable: false
        },
        primitive: _l7Core.gl.POINTS
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 5
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });

    // point layer uv;
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: feature => {
          const iconMap = this.iconService.getIconMap();
          const {
            shape
          } = feature;
          const {
            x,
            y
          } = iconMap[shape] || {
            x: -64,
            y: -64
          }; // 非画布区域，默认的图标改为透明
          return [x, y];
        }
      }
    });
  }
}
exports.default = ImageModel;