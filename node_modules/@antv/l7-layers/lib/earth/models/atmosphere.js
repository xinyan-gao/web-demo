"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _CommonStyleAttribute = require("../../core/CommonStyleAttribute");
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/atmosphere/atmosphere_frag.glsl' */
const atmoSphereFrag = "\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\nin vec3 vVertexNormal;\nin float v_offset;\nin vec4 v_Color;\n\n#pragma include \"scene_uniforms\"\nout vec4 outputColor;\nvoid main() {\n    \n    \n    // float intensity = pow(0.5 + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    float intensity = pow(v_offset + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    // \u53BB\u9664\u80CC\u9762\n    if(intensity > 1.0) intensity = 0.0;\n\n    outputColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\n}\n";
/* babel-plugin-inline-import '../shaders/atmosphere/atmosphere_vert.glsl' */
const atmoSphereVert = "layout(location = 0) in vec3 a_Position;\nlayout(location = 1) vec4 a_Color;\nlayout(location = 13) in vec3 a_Normal;\nlayout(location = 14) in vec2 a_Uv;\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\n#pragma include \"scene_uniforms\"\nout vec3 vVertexNormal;\nout vec4 v_Color;\nout float v_offset;\n\nvoid main() {\n    float EARTH_RADIUS = 100.0;\n    \n    v_Color = a_Color;\n\n    v_offset = min(((length(u_CameraPosition) - EARTH_RADIUS)/600.0) * 0.5 + 0.4, 1.0);\n    vVertexNormal = a_Normal;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n";
const {
  isNumber
} = _l7Utils.lodashUtil;
class EarthAtomSphereModel extends _BaseModel.default {
  getCommonUniformsInfo() {
    const {
      opacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_opacity: isNumber(opacity) ? opacity : 1.0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  clearModels() {
    return '';
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      // TODO: 调整图层的绘制顺序 地球大气层
      _this2.layer.zIndex = -997;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'earthAtmoSphere',
        vertexShader: atmoSphereVert,
        fragmentShader: atmoSphereFrag,
        triangulation: _triangulation.earthTriangulation,
        depth: {
          enable: false
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.SIZE,
        buffer: {
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.NORMAL,
        buffer: {
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: _CommonStyleAttribute.ShaderLocation.UV,
        buffer: {
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}
exports.default = EarthAtomSphereModel;