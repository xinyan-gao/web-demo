"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _glMatrix = require("gl-matrix");
const DEGREES_TO_RADIANS = Math.PI / 180;
class Viewport {
  constructor() {
    (0, _defineProperty2.default)(this, "projectionMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "ViewProjectionMatrixUncentered", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewUncenteredMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "zoom", void 0);
    (0, _defineProperty2.default)(this, "center", void 0);
  }
  syncWithMapCamera(mapCamera) {
    const {
      zoom = 1,
      pitch = 0,
      bearing = 0,
      center = [0, 0],
      offsetOrigin = [0, 0],
      cameraHeight = 1,
      aspect = 1,
      near = 0.1,
      far = 1000,
      fov = 0
    } = mapCamera;
    this.zoom = zoom;
    this.center = center;
    const pitchInRadians = pitch * DEGREES_TO_RADIANS;
    const rotationInRadians = (360 - bearing) * DEGREES_TO_RADIANS;

    // 计算透视投影矩阵 projectionMatrix
    _glMatrix.mat4.perspective(this.projectionMatrix, fov, aspect, near, far);
    // 计算相机矩阵 viewMatrix
    const eye = _glMatrix.vec3.fromValues(cameraHeight * Math.sin(pitchInRadians) * Math.sin(rotationInRadians), -cameraHeight * Math.sin(pitchInRadians) * Math.cos(rotationInRadians), cameraHeight * Math.cos(pitchInRadians));
    const up = _glMatrix.vec3.fromValues(-Math.cos(pitchInRadians) * Math.sin(rotationInRadians), Math.cos(pitchInRadians) * Math.cos(rotationInRadians), Math.sin(pitchInRadians));
    _glMatrix.mat4.lookAt(this.viewMatrix, eye, _glMatrix.vec3.fromValues(0, 0, 0), up);
    this.viewUncenteredMatrix = _glMatrix.mat4.clone(this.viewMatrix);

    // 移动相机位置
    _glMatrix.mat4.translate(this.viewMatrix, this.viewMatrix, _glMatrix.vec3.fromValues(-offsetOrigin[0], offsetOrigin[1], 0));
    _glMatrix.mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
    _glMatrix.mat4.multiply(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix);
  }
  getZoom() {
    return this.zoom;
  }
  getZoomScale() {
    // 512 尺寸下的缩放：2 ^ 19
    return 524288;
  }
  getCenter() {
    const [lng, lat] = this.center;
    return [lng, lat];
  }
  getProjectionMatrix() {
    // @ts-ignore
    return this.projectionMatrix;
  }
  getModelMatrix() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  getViewMatrix() {
    // @ts-ignore
    return this.viewMatrix;
  }
  getViewMatrixUncentered() {
    // @ts-ignore
    return this.viewUncenteredMatrix;
  }
  getViewProjectionMatrix() {
    // @ts-ignore
    return this.viewProjectionMatrix;
  }
  getViewProjectionMatrixUncentered() {
    // @ts-ignore
    return this.ViewProjectionMatrixUncentered;
  }
  getFocalDistance() {
    return 1;
  }

  /**
   * P20 坐标系，固定 scale
   */
  projectFlat(lngLat) {
    const maxs = 85.0511287798;
    const lat = Math.max(Math.min(maxs, lngLat[1]), -maxs);
    // tslint:disable-next-line:no-bitwise
    const zoomScale = 256 << 20;
    let d = Math.PI / 180;
    let x = lngLat[0] * d;
    let y = lat * d;
    y = Math.log(Math.tan(Math.PI / 4 + y / 2));
    const a = 0.5 / Math.PI;
    const b = 0.5;
    const c = -0.5 / Math.PI;
    d = 0.5;
    x = zoomScale * (a * x + b) - 215440491;
    y = -(zoomScale * (c * y + d) - 106744817);
    return [x, y];
  }
}
exports.default = Viewport;