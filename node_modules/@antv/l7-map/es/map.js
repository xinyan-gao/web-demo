import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { DOM, lodashUtil } from '@antv/l7-utils';
import Camera from "./camera";
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(`.l7-map {
  font:
    12px/20px 'Helvetica Neue',
    Arial,
    Helvetica,
    sans-serif;
  overflow: hidden;
  position: relative;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.l7-canvas {
  position: absolute;
  left: 0;
  top: 0;
}

.l7-map:-webkit-full-screen {
  width: 100%;
  height: 100%;
}

.l7-canary {
  background-color: salmon;
}

.l7-canvas-container.l7-interactive,
.l7-ctrl-group button.l7-ctrl-compass {
  cursor: grab;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.l7-canvas-container.l7-interactive.l7-track-pointer {
  cursor: pointer;
}

.l7-canvas-container.l7-interactive:active,
.l7-ctrl-group button.l7-ctrl-compass:active {
  cursor: grabbing;
}

.l7-canvas-container.l7-touch-zoom-rotate,
.l7-canvas-container.l7-touch-zoom-rotate .l7-canvas {
  touch-action: pan-x pan-y;
}

.l7-canvas-container.l7-touch-drag-pan,
.l7-canvas-container.l7-touch-drag-pan .l7-canvas {
  touch-action: pinch-zoom;
}

.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan,
.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan .l7-canvas {
  touch-action: none;
}

.l7-ctrl-top-left,
.l7-ctrl-top-right,
.l7-ctrl-bottom-left,
.l7-ctrl-bottom-right {
  position: absolute;
  pointer-events: none;
  z-index: 2;
}
.l7-ctrl-top-left {
  top: 0;
  left: 0;
}
.l7-ctrl-top-right {
  top: 0;
  right: 0;
}
.l7-ctrl-bottom-left {
  bottom: 0;
  left: 0;
}
.l7-ctrl-bottom-right {
  right: 0;
  bottom: 0;
}

.l7-ctrl {
  clear: both;
  pointer-events: auto;

  /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */
  -webkit-transform: translate(0, 0);
          transform: translate(0, 0);
}
.l7-ctrl-top-left .l7-ctrl {
  margin: 10px 0 0 10px;
  float: left;
}
.l7-ctrl-top-right .l7-ctrl {
  margin: 10px 10px 0 0;
  float: right;
}
.l7-ctrl-bottom-left .l7-ctrl {
  margin: 0 0 10px 10px;
  float: left;
}
.l7-ctrl-bottom-right .l7-ctrl {
  margin: 0 10px 10px 0;
  float: right;
}

.l7-crosshair,
.l7-crosshair .l7-interactive,
.l7-crosshair .l7-interactive:active {
  cursor: crosshair;
}

.l7-boxzoom {
  position: absolute;
  top: 0;
  left: 0;
  width: 0;
  height: 0;
  background: #fff;
  border: 2px dotted #202020;
  opacity: 0.5;
  z-index: 10;
}
`);
import LngLat from "./geo/lng_lat";
import LngLatBounds from "./geo/lng_lat_bounds";
// @ts-ignore

import Point from "./geo/point";
import HandlerManager from "./handler/handler_manager";
import Hash from "./hash";
import { renderframe } from "./util";
import { PerformanceUtils } from "./utils/performance";
import TaskQueue from "./utils/task_queue";
(function () {
  if (typeof window.CustomEvent === 'function') return false; //If not IE

  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    const evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }
  CustomEvent.prototype = window.Event.prototype;
  // @ts-ignore
  window.CustomEvent = CustomEvent;
})();
const defaultMinZoom = -2;
const defaultMaxZoom = 22;
const {
  merge
} = lodashUtil;
// the default values, but also the valid range
const defaultMinPitch = 0;
const defaultMaxPitch = 60;
const DefaultOptions = {
  hash: false,
  zoom: -1,
  center: [112, 32],
  pitch: 0,
  bearing: 0,
  interactive: true,
  minZoom: defaultMinZoom,
  maxZoom: defaultMaxZoom,
  minPitch: defaultMinPitch,
  maxPitch: defaultMaxPitch,
  scrollZoom: true,
  boxZoom: true,
  dragRotate: true,
  dragPan: true,
  keyboard: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  touchPitch: true,
  bearingSnap: 7,
  clickTolerance: 3,
  pitchWithRotate: true,
  trackResize: true,
  renderWorldCopies: true,
  pitchEnabled: true,
  rotateEnabled: true
};
export class Map extends Camera {
  constructor(options) {
    super(merge({}, DefaultOptions, options));
    _defineProperty(this, "doubleClickZoom", void 0);
    _defineProperty(this, "dragRotate", void 0);
    _defineProperty(this, "dragPan", void 0);
    _defineProperty(this, "touchZoomRotate", void 0);
    _defineProperty(this, "scrollZoom", void 0);
    _defineProperty(this, "keyboard", void 0);
    _defineProperty(this, "touchPitch", void 0);
    _defineProperty(this, "boxZoom", void 0);
    _defineProperty(this, "handlers", void 0);
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "canvas", void 0);
    _defineProperty(this, "canvasContainer", void 0);
    _defineProperty(this, "renderTaskQueue", new TaskQueue());
    _defineProperty(this, "frame", void 0);
    _defineProperty(this, "trackResize", true);
    _defineProperty(this, "hash", void 0);
    _defineProperty(this, "onWindowOnline", () => {
      this.update();
    });
    _defineProperty(this, "onWindowResize", event => {
      if (this.trackResize) {
        this.resize({
          originalEvent: event
        }).update();
      }
    });
    this.initContainer();
    this.resize();
    this.handlers = new HandlerManager(this, this.options);
    if (typeof window !== 'undefined') {
      window.addEventListener('online', this.onWindowOnline, false);
      window.addEventListener('resize', this.onWindowResize, false);
      window.addEventListener('orientationchange', this.onWindowResize, false);
    }
    const hashName = typeof options.hash === 'string' && options.hash || undefined;
    if (options.hash) {
      this.hash = new Hash(hashName).addTo(this);
    }

    // don't set position from options if set through hash
    if (!this.hash || !this.hash.onHashChange()) {
      this.jumpTo({
        center: options.center,
        zoom: options.zoom,
        bearing: options.bearing,
        pitch: options.pitch
      });
      if (options.bounds) {
        this.resize();
        this.fitBounds(options.bounds, merge({}, options.fitBoundsOptions, {
          duration: 0
        }));
      }
    }
  }
  resize(eventData) {
    const [width, height] = this.containerDimensions();
    this.transform.resize(width, height);
    // 小程序环境不需要执行后续动作
    const fireMoving = !this.moving;
    if (fireMoving) {
      this.stop();
      this.emit('movestart', new window.CustomEvent('movestart', eventData));
      this.emit('move', new window.CustomEvent('move', eventData));
    }
    this.emit('resize', new window.CustomEvent('resize', eventData));
    if (fireMoving) {
      this.emit('moveend', new window.CustomEvent('moveend', eventData));
    }
    return this;
  }
  getContainer() {
    return this.container;
  }
  getCanvas() {
    return this.canvas;
  }
  getCanvasContainer() {
    return this.canvasContainer;
  }
  getCanvasOverlays() {
    return this.getCanvasContainer();
  }
  project(lngLat) {
    return this.transform.locationPoint(LngLat.convert(lngLat));
  }
  unproject(point) {
    return this.transform.pointLocation(Point.convert(point));
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(bounds) {
    this.transform.setMaxBounds(LngLatBounds.convert(bounds));
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setStyle(style) {
    return;
  }
  setMinZoom(minZoom) {
    minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;
    if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
      this.transform.minZoom = minZoom;
      if (this.getZoom() < minZoom) {
        this.setZoom(minZoom);
      }
      return this;
    } else {
      throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);
    }
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(maxZoom) {
    maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;
    if (maxZoom >= this.transform.minZoom) {
      this.transform.maxZoom = maxZoom;
      if (this.getZoom() > maxZoom) {
        this.setZoom(maxZoom);
      }
      return this;
    } else {
      throw new Error('maxZoom must be greater than the current minZoom');
    }
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(minPitch) {
    minPitch = minPitch === null || minPitch === undefined ? defaultMinPitch : minPitch;
    if (minPitch < defaultMinPitch) {
      throw new Error(`minPitch must be greater than or equal to ${defaultMinPitch}`);
    }
    if (minPitch >= defaultMinPitch && minPitch <= this.transform.maxPitch) {
      this.transform.minPitch = minPitch;
      if (this.getPitch() < minPitch) {
        this.setPitch(minPitch);
      }
      return this;
    } else {
      throw new Error(`minPitch must be between ${defaultMinPitch} and the current maxPitch, inclusive`);
    }
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(maxPitch) {
    maxPitch = maxPitch === null || maxPitch === undefined ? defaultMaxPitch : maxPitch;
    if (maxPitch > defaultMaxPitch) {
      throw new Error(`maxPitch must be less than or equal to ${defaultMaxPitch}`);
    }
    if (maxPitch >= this.transform.minPitch) {
      this.transform.maxPitch = maxPitch;
      if (this.getPitch() > maxPitch) {
        this.setPitch(maxPitch);
      }
      return this;
    } else {
      throw new Error('maxPitch must be greater than the current minPitch');
    }
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(renderWorldCopies) {
    this.transform.renderWorldCopies = !!renderWorldCopies;
  }
  remove() {
    this.container.removeChild(this.canvasContainer);
    // @ts-ignore
    this.canvasContainer = null;
    if (this.frame) {
      this.frame.cancel();
      this.frame = null;
    }
    this.renderTaskQueue.clear();
    //销毁事件
    this.handlers.destroy();
    if (typeof window !== 'undefined') {
      window.removeEventListener('online', this.onWindowOnline, false);
      window.removeEventListener('resize', this.onWindowResize, false);
      window.removeEventListener('orientationchange', this.onWindowResize, false);
    }
  }
  requestRenderFrame(cb) {
    this.update();
    return this.renderTaskQueue.add(cb);
  }
  cancelRenderFrame(id) {
    return this.renderTaskQueue.remove(id);
  }
  triggerRepaint() {
    if (!this.frame) {
      this.frame = renderframe(paintStartTimeStamp => {
        PerformanceUtils.frame(paintStartTimeStamp);
        this.frame = null;
        this.update(paintStartTimeStamp);
      });
    }
  }
  update(time) {
    if (!this.frame) {
      this.frame = renderframe(paintStartTimeStamp => {
        PerformanceUtils.frame(paintStartTimeStamp);
        this.frame = null;
        this.renderTaskQueue.run(time);
      });
    }
  }
  initContainer() {
    if (typeof this.options.container === 'string') {
      this.container = window.document.getElementById(this.options.container);
      if (!this.container) {
        throw new Error(`Container '${this.options.container}' not found.`);
      }
    } else if (this.options.container instanceof HTMLElement) {
      this.container = this.options.container;
    } else {
      throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    }
    const container = this.container;
    container.classList.add('l7-map');
    const canvasContainer = this.canvasContainer = DOM.create('div', 'l7-canvas-container', container);
    if (this.options.interactive) {
      canvasContainer.classList.add('l7-interactive');
    }
  }
  containerDimensions() {
    let width = 0;
    let height = 0;
    if (this.container) {
      width = this.container.clientWidth;
      height = this.container.clientHeight;
      width = width === 0 ? 400 : width;
      height = height === 0 ? 300 : height;
    }
    return [width, height];
  }
}