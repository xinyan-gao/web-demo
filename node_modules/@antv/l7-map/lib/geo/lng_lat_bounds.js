"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _lng_lat = _interopRequireDefault(require("./lng_lat"));
class LngLatBounds {
  static convert(input) {
    if (input instanceof LngLatBounds) {
      return input;
    }
    return new LngLatBounds(input);
  }
  constructor(sw, ne) {
    (0, _defineProperty2.default)(this, "ne", void 0);
    (0, _defineProperty2.default)(this, "sw", void 0);
    if (!sw) {
      // noop
    } else if (ne) {
      this.setSouthWest(sw).setNorthEast(ne);
    } else if (sw.length === 4) {
      this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);
    } else {
      this.setSouthWest(sw[0]).setNorthEast(sw[1]);
    }
  }
  setNorthEast(ne) {
    this.ne = ne instanceof _lng_lat.default ? new _lng_lat.default(ne.lng, ne.lat) : _lng_lat.default.convert(ne);
    return this;
  }
  setSouthWest(sw) {
    this.sw = sw instanceof _lng_lat.default ? new _lng_lat.default(sw.lng, sw.lat) : _lng_lat.default.convert(sw);
    return this;
  }
  extend(obj) {
    const sw = this.sw;
    const ne = this.ne;
    let sw2;
    let ne2;
    if (obj instanceof _lng_lat.default) {
      sw2 = obj;
      ne2 = obj;
    } else if (obj instanceof LngLatBounds) {
      sw2 = obj.sw;
      ne2 = obj.ne;
      if (!sw2 || !ne2) {
        return this;
      }
    } else {
      if (Array.isArray(obj)) {
        // @ts-ignore
        if (obj.length === 4 || obj.every(Array.isArray)) {
          const lngLatBoundsObj = obj;
          return this.extend(LngLatBounds.convert(lngLatBoundsObj));
        } else {
          const lngLatObj = obj;
          return this.extend(_lng_lat.default.convert(lngLatObj));
        }
      }
      return this;
    }
    if (!sw && !ne) {
      this.sw = new _lng_lat.default(sw2.lng, sw2.lat);
      this.ne = new _lng_lat.default(ne2.lng, ne2.lat);
    } else {
      sw.lng = Math.min(sw2.lng, sw.lng);
      sw.lat = Math.min(sw2.lat, sw.lat);
      ne.lng = Math.max(ne2.lng, ne.lng);
      ne.lat = Math.max(ne2.lat, ne.lat);
    }
    return this;
  }
  getCenter() {
    return new _lng_lat.default((this.sw.lng + this.ne.lng) / 2, (this.sw.lat + this.ne.lat) / 2);
  }
  getSouthWest() {
    return this.sw;
  }
  getNorthEast() {
    return this.ne;
  }
  getNorthWest() {
    return new _lng_lat.default(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new _lng_lat.default(this.getEast(), this.getSouth());
  }
  getWest() {
    return this.sw.lng;
  }
  getSouth() {
    return this.sw.lat;
  }
  getEast() {
    return this.ne.lng;
  }
  getNorth() {
    return this.ne.lat;
  }
  toArray() {
    return [this.sw.toArray(), this.ne.toArray()];
  }
  toString() {
    return `LngLatBounds(${this.sw.toString()}, ${this.ne.toString()})`;
  }
  isEmpty() {
    return !(this.sw && this.ne);
  }
  contains(lnglat) {
    const {
      lng,
      lat
    } = _lng_lat.default.convert(lnglat);
    const containsLatitude = this.sw.lat <= lat && lat <= this.ne.lat;
    let containsLongitude = this.sw.lng <= lng && lng <= this.ne.lng;
    if (this.sw.lng > this.ne.lng) {
      // wrapped coordinates
      containsLongitude = this.sw.lng >= lng && lng >= this.ne.lng;
    }
    return containsLatitude && containsLongitude;
  }
}
exports.default = LngLatBounds;