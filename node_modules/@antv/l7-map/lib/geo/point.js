"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
class Point {
  static convert(a) {
    if (a instanceof Point) {
      return a;
    }
    if (Array.isArray(a)) {
      return new Point(a[0], a[1]);
    }
    return a;
  }
  constructor(x, y) {
    (0, _defineProperty2.default)(this, "x", void 0);
    (0, _defineProperty2.default)(this, "y", void 0);
    this.x = x;
    this.y = y;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  _add(p) {
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  add(p) {
    return this.clone()._add(p);
  }
  _sub(p) {
    this.x -= p.x;
    this.y -= p.y;
    return this;
  }
  sub(p) {
    return this.clone()._sub(p);
  }
  _multByPoint(p) {
    this.x *= p.x;
    this.y *= p.y;
    return this;
  }
  multByPoint(p) {
    return this.clone()._multByPoint(p);
  }
  _divByPoint(p) {
    this.x /= p.x;
    this.y /= p.y;
    return this;
  }
  divByPoint(p) {
    return this.clone()._divByPoint(p);
  }
  _mult(k) {
    this.x *= k;
    this.y *= k;
    return this;
  }
  mult(k) {
    return this.clone()._mult(k);
  }
  _div(k) {
    this.x /= k;
    this.y /= k;
    return this;
  }
  div(k) {
    return this.clone()._div(k);
  }
  _rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = cos * this.x - sin * this.y;
    const y = sin * this.x + cos * this.y;
    this.x = x;
    this.y = y;
    return this;
  }
  rotate(angle) {
    return this.clone()._rotate(angle);
  }
  _rotateAround(angle, p) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);
    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
    this.x = x;
    this.y = y;
    return this;
  }
  roateAround(angle, p) {
    return this.clone()._rotateAround(angle, p);
  }
  _matMult(m) {
    const x = m[0] * this.x + m[1] * this.y;
    const y = m[2] * this.x + m[3] * this.y;
    this.x = x;
    this.y = y;
    return this;
  }
  matMult(m) {
    return this.clone()._matMult(m);
  }
  _unit() {
    this.div(this.mag());
    return this;
  }
  unit() {
    return this.clone()._unit();
  }
  _perp() {
    const y = this.y;
    this.y = this.x;
    this.x = -y;
    return this;
  }
  perp() {
    return this.clone()._perp();
  }
  _round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  round() {
    return this.clone()._round();
  }
  mag() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  dist(p) {
    return Math.sqrt(this.distSqr(p));
  }
  distSqr(p) {
    const dx = p.x - this.x;
    const dy = p.y - this.y;
    return dx * dx + dy * dy;
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  angleTo(b) {
    return Math.atan2(this.y - b.y, this.x - b.x);
  }
  angleWith(b) {
    return this.angleWithSep(b.x, b.y);
  }
  angleWithSep(x, y) {
    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
  }
}
exports.default = Point;