"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerformanceUtils = exports.PerformanceMarkers = void 0;
let lastFrameTime = null;
let frameTimes = [];
const minFramerateTarget = 30;
const frameTimeTarget = 1000 / minFramerateTarget;
const performance = window.performance;
const PerformanceMarkers = exports.PerformanceMarkers = {
  create: 'create',
  load: 'load',
  fullLoad: 'fullLoad'
};
const PerformanceUtils = exports.PerformanceUtils = {
  mark(marker) {
    performance.mark(marker);
  },
  frame(timestamp) {
    const currTimestamp = timestamp;
    if (lastFrameTime != null) {
      const frameTime = currTimestamp - lastFrameTime;
      frameTimes.push(frameTime);
    }
    lastFrameTime = currTimestamp;
  },
  clearMetrics() {
    lastFrameTime = null;
    frameTimes = [];
    performance.clearMeasures('loadTime');
    performance.clearMeasures('fullLoadTime');
    // @ts-ignore
    // tslint:disable-next-line:forin
    for (const marker in PerformanceMarkers) {
      // @ts-ignore
      performance.clearMarks(PerformanceMarkers[marker]);
    }
  },
  getPerformanceMetrics() {
    const loadTime = performance.measure('loadTime', PerformanceMarkers.create, PerformanceMarkers.load
    // @ts-ignore
    ).duration;
    const fullLoadTime = performance.measure('fullLoadTime', PerformanceMarkers.create, PerformanceMarkers.fullLoad
    // @ts-ignore
    ).duration;
    const totalFrames = frameTimes.length;
    const avgFrameTime = frameTimes.reduce((prev, curr) => prev + curr, 0) / totalFrames / 1000;
    const fps = 1 / avgFrameTime;

    // count frames that missed our framerate target
    const droppedFrames = frameTimes.filter(frameTime => frameTime > frameTimeTarget).reduce((acc, curr) => {
      return acc + (curr - frameTimeTarget) / frameTimeTarget;
    }, 0);
    const percentDroppedFrames = droppedFrames / (totalFrames + droppedFrames) * 100;
    return {
      loadTime,
      fullLoadTime,
      fps,
      percentDroppedFrames
    };
  }
};