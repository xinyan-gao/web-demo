"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _glMatrix = require("gl-matrix");
class Frustum {
  static fromInvProjectionMatrix(invProj, worldSize, zoom) {
    const clipSpaceCorners = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]];
    const scale = Math.pow(2, zoom);

    // Transform frustum corner points from clip space to tile space
    const frustumCoords = clipSpaceCorners.map(v => _glMatrix.vec4.transformMat4(new Float32Array([]), v, invProj)).map(v => _glMatrix.vec4.scale(new Float32Array([]), v, 1.0 / v[3] / worldSize * scale));
    const frustumPlanePointIndices = [[0, 1, 2],
    // near
    [6, 5, 4],
    // far
    [0, 3, 7],
    // left
    [2, 1, 5],
    // right
    [3, 2, 6],
    // bottom
    [0, 4, 5] // top
    ];
    const frustumPlanes = frustumPlanePointIndices.map(p => {
      const a = _glMatrix.vec3.sub(new Float32Array(3), new Float32Array(frustumCoords[p[0]]), new Float32Array(frustumCoords[p[1]]));
      const b = _glMatrix.vec3.sub(new Float32Array(3), new Float32Array(frustumCoords[p[2]]), new Float32Array(frustumCoords[p[1]]));
      const n = _glMatrix.vec3.normalize(new Float32Array(3), _glMatrix.vec3.cross(new Float32Array(3), a, b));
      const d = -_glMatrix.vec3.dot(n, new Float32Array(frustumCoords[p[1]]));
      return n.concat(d);
    });
    return new Frustum(frustumCoords, frustumPlanes);
  }
  constructor(points, planes) {
    (0, _defineProperty2.default)(this, "points", void 0);
    (0, _defineProperty2.default)(this, "planes", void 0);
    this.points = points;
    this.planes = planes;
  }
}
exports.default = Frustum;