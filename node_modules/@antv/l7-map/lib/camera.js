"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _eventemitter = require("eventemitter3");
var _lng_lat = _interopRequireDefault(require("./geo/lng_lat"));
var _lng_lat_bounds = _interopRequireDefault(require("./geo/lng_lat_bounds"));
var _point = _interopRequireDefault(require("./geo/point"));
var _transform = _interopRequireDefault(require("./geo/transform"));
var _event = require("./handler/events/event");
var _util = require("./util");
// @ts-ignore

const {
  merge
} = _l7Utils.lodashUtil;
class Camera extends _eventemitter.EventEmitter {
  constructor(options) {
    super();
    (0, _defineProperty2.default)(this, "transform", void 0);
    // public requestRenderFrame: (_: any) => number;
    // public cancelRenderFrame: (_: number) => void;
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "moving", void 0);
    (0, _defineProperty2.default)(this, "zooming", void 0);
    (0, _defineProperty2.default)(this, "rotating", void 0);
    (0, _defineProperty2.default)(this, "pitching", void 0);
    (0, _defineProperty2.default)(this, "padding", void 0);
    (0, _defineProperty2.default)(this, "bearingSnap", void 0);
    (0, _defineProperty2.default)(this, "easeEndTimeoutID", void 0);
    (0, _defineProperty2.default)(this, "easeStart", void 0);
    (0, _defineProperty2.default)(this, "easeOptions", void 0);
    (0, _defineProperty2.default)(this, "easeId", void 0);
    (0, _defineProperty2.default)(this, "onEaseFrame", void 0);
    (0, _defineProperty2.default)(this, "onEaseEnd", void 0);
    (0, _defineProperty2.default)(this, "easeFrameId", void 0);
    (0, _defineProperty2.default)(this, "pitchEnabled", void 0);
    (0, _defineProperty2.default)(this, "rotateEnabled", void 0);
    (0, _defineProperty2.default)(this, "renderFrameCallback", () => {
      const t = Math.min(((0, _util.now)() - this.easeStart) / this.easeOptions.duration, 1);
      this.onEaseFrame(this.easeOptions.easing(t));
      if (t < 1) {
        // this.easeFrameId = window.requestAnimationFrame(this.renderFrameCallback);
        this.easeFrameId = this.requestRenderFrame(this.renderFrameCallback);
      } else {
        this.stop();
      }
    });
    this.options = options;
    const {
      minZoom,
      maxZoom,
      minPitch,
      maxPitch,
      renderWorldCopies
    } = options;
    this.moving = false;
    this.zooming = false;
    this.bearingSnap = options.bearingSnap;
    this.pitchEnabled = options.pitchEnabled;
    this.rotateEnabled = options.rotateEnabled;
    this.transform = new _transform.default(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  requestRenderFrame(cb) {
    return 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  cancelRenderFrame(_) {
    return;
  }
  getCenter() {
    const {
      lng,
      lat
    } = this.transform.center;
    return new _lng_lat.default(lng, lat);
  }
  getZoom() {
    return this.transform.zoom;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setCenter(center, eventData) {
    return this.jumpTo({
      center
    }, eventData);
  }
  setPitch(pitch, eventData) {
    this.jumpTo({
      pitch
    }, eventData);
    return this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  panTo(lnglat, options, eventData) {
    return this.easeTo(merge({
      center: lnglat
    }, options), eventData);
  }
  panBy(offset, options, eventData) {
    offset = _point.default.convert(offset).mult(-1);
    return this.panTo(this.transform.center, (0, _util.extend)({
      offset
    }, options || {}), eventData);
  }
  zoomOut(options, eventData) {
    this.zoomTo(this.getZoom() - 1, options, eventData);
    return this;
  }
  setBearing(bearing, eventData) {
    this.jumpTo({
      bearing
    }, eventData);
    return this;
  }
  setZoom(zoom, eventData) {
    this.jumpTo({
      zoom
    }, eventData);
    return this;
  }
  zoomIn(options, eventData) {
    this.zoomTo(this.getZoom() + 1, options, eventData);
    return this;
  }
  zoomTo(zoom, options, eventData) {
    return this.easeTo(merge({
      zoom
    }, options), eventData);
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(padding, eventData) {
    this.jumpTo({
      padding
    }, eventData);
    return this;
  }
  rotateTo(bearing, options, eventData) {
    return this.easeTo(merge({
      bearing
    }, options), eventData);
  }
  resetNorth(options, eventData) {
    this.rotateTo(0, merge({
      duration: 1000
    }, options), eventData);
    return this;
  }
  resetNorthPitch(options, eventData) {
    this.easeTo(merge({
      bearing: 0,
      pitch: 0,
      duration: 1000
    }, options), eventData);
    return this;
  }
  fitBounds(bounds, options, eventData) {
    return this.fitInternal(
    // @ts-ignore
    this.cameraForBounds(bounds, options), options, eventData);
  }
  cameraForBounds(bounds, options) {
    bounds = _lng_lat_bounds.default.convert(bounds);
    return this.cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), 0,
    // @ts-ignore
    options);
  }
  snapToNorth(options, eventData) {
    if (Math.abs(this.getBearing()) < this.bearingSnap) {
      return this.resetNorth(options, eventData);
    }
    return this;
  }
  jumpTo(options = {}, eventData) {
    this.stop();
    const tr = this.transform;
    let zoomChanged = false;
    let bearingChanged = false;
    let pitchChanged = false;
    if (options.zoom !== undefined && tr.zoom !== +options.zoom) {
      zoomChanged = true;
      tr.zoom = +options.zoom;
    }
    if (options.center !== undefined) {
      tr.center = _lng_lat.default.convert(options.center);
    }
    if (options.bearing !== undefined && tr.bearing !== +options.bearing) {
      bearingChanged = true;
      tr.bearing = +options.bearing;
    }
    if (options.pitch !== undefined && tr.pitch !== +options.pitch) {
      pitchChanged = true;
      tr.pitch = +options.pitch;
    }
    if (options.padding !== undefined && !tr.isPaddingEqual(options.padding)) {
      tr.padding = options.padding;
    }
    this.emit('movestart', new _event.Event('movestart', eventData));
    this.emit('move', new _event.Event('move', eventData));
    if (zoomChanged) {
      this.emit('zoomstart', new _event.Event('zoomstart', eventData));
      this.emit('zoom', new _event.Event('zoom', eventData));
      this.emit('zoomend', new _event.Event('zoomend', eventData));
    }
    if (bearingChanged) {
      this.emit('rotatestart', new _event.Event('rotatestart', eventData));
      this.emit('rotate', new _event.Event('rotate', eventData));
      this.emit('rotateend', new _event.Event('rotateend', eventData));
    }
    if (pitchChanged) {
      this.emit('pitchstart', new _event.Event('pitchstart', eventData));
      this.emit('pitch', new _event.Event('pitch', eventData));
      this.emit('pitchend', new _event.Event('pitchend', eventData));
    }
    return this.emit('moveend', new _event.Event('moveend', eventData));
  }
  easeTo(options = {}, eventData) {
    options = merge({
      offset: [0, 0],
      duration: 500,
      easing: _util.ease
    }, options);
    if (options.animate === false || !options.essential && (0, _util.prefersReducedMotion)()) {
      options.duration = 0;
    }
    const tr = this.transform;
    const startZoom = this.getZoom();
    const startBearing = this.getBearing();
    const startPitch = this.getPitch();
    const startPadding = this.getPadding();
    const zoom = options.zoom ? +options.zoom : startZoom;
    const bearing = options.bearing ? this.normalizeBearing(options.bearing, startBearing) : startBearing;
    const pitch = options.pitch ? +options.pitch : startPitch;
    const padding = options.padding ? options.padding : tr.padding;
    const offsetAsPoint = _point.default.convert(options.offset);
    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);
    const locationAtOffset = tr.pointLocation(pointAtOffset);
    const center = _lng_lat.default.convert(options.center || locationAtOffset);
    this.normalizeCenter(center);
    const from = tr.project(locationAtOffset);
    const delta = tr.project(center).sub(from);
    const finalScale = tr.zoomScale(zoom - startZoom);
    let around;
    let aroundPoint;
    if (options.around) {
      around = _lng_lat.default.convert(options.around);
      aroundPoint = tr.locationPoint(around);
    }
    const currently = {
      moving: this.moving,
      zooming: this.zooming,
      rotating: this.rotating,
      pitching: this.pitching
    };
    this.zooming = this.zooming || zoom !== startZoom;
    this.rotating = this.rotating || startBearing !== bearing;
    this.pitching = this.pitching || pitch !== startPitch;
    this.padding = !tr.isPaddingEqual(padding);
    this.easeId = options.easeId;
    this.prepareEase(eventData, options.noMoveStart, currently);
    clearTimeout(this.easeEndTimeoutID);
    this.ease(k => {
      if (this.zooming) {
        tr.zoom = (0, _util.interpolate)(startZoom, zoom, k);
      }
      if (this.rotating && this.rotateEnabled) {
        tr.bearing = (0, _util.interpolate)(startBearing, bearing, k);
      }
      if (this.pitching && this.pitchEnabled) {
        tr.pitch = (0, _util.interpolate)(startPitch, pitch, k);
      }
      if (this.padding) {
        tr.interpolatePadding(startPadding, padding, k);
        // When padding is being applied, Transform#centerPoint is changing continously,
        // thus we need to recalculate offsetPoint every fra,e
        pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      }
      if (around) {
        tr.setLocationAtPoint(around, aroundPoint);
      } else {
        const scale = tr.zoomScale(tr.zoom - startZoom);
        const base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);
        const speedup = Math.pow(base, 1 - k);
        const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));
        tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
      }
      this.fireMoveEvents(eventData);
    }, interruptingEaseId => {
      this.afterEase(eventData, interruptingEaseId);
    },
    // @ts-ignore
    options);
    return this;
  }
  flyTo(options = {}, eventData) {
    // Fall through to jumpTo if user has set prefers-reduced-motion
    if (!options.essential && (0, _util.prefersReducedMotion)()) {
      const coercedOptions = (0, _util.pick)(options, ['center', 'zoom', 'bearing', 'pitch', 'around']);
      return this.jumpTo(coercedOptions, eventData);
    }
    this.stop();
    options = merge({
      offset: [0, 0],
      speed: 1.2,
      curve: 1.42,
      easing: _util.ease
    }, options);
    const tr = this.transform;
    const startZoom = this.getZoom();
    const startBearing = this.getBearing();
    const startPitch = this.getPitch();
    const startPadding = this.getPadding();
    const zoom = options.zoom ? (0, _util.clamp)(+options.zoom, tr.minZoom, tr.maxZoom) : startZoom;
    const bearing = options.bearing ? this.normalizeBearing(options.bearing, startBearing) : startBearing;
    const pitch = options.pitch ? +options.pitch : startPitch;
    const padding = 'padding' in options ? options.padding : tr.padding;
    const scale = tr.zoomScale(zoom - startZoom);
    const offsetAsPoint = _point.default.convert(options.offset);
    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);
    const locationAtOffset = tr.pointLocation(pointAtOffset);
    const center = _lng_lat.default.convert(options.center || locationAtOffset);
    this.normalizeCenter(center);
    const from = tr.project(locationAtOffset);
    const delta = tr.project(center).sub(from);
    let rho = options.curve;

    // w₀: Initial visible span, measured in pixels at the initial scale.
    const w0 = Math.max(tr.width, tr.height);
    // w₁: Final visible span, measured in pixels with respect to the initial scale.
    const w1 = w0 / scale;
    // Length of the flight path as projected onto the ground plane, measured in pixels from
    // the world image origin at the initial scale.
    const u1 = delta.mag();
    if ('minZoom' in options) {
      const minZoom = (0, _util.clamp)(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
      // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
      // scale.
      const wMax = w0 / tr.zoomScale(minZoom - startZoom);
      rho = Math.sqrt(wMax / u1 * 2);
    }

    // ρ²
    const rho2 = rho * rho;

    /**
     * rᵢ: Returns the zoom-out factor at one end of the animation.
     *
     * @param i 0 for the ascent or 1 for the descent.
     * @private
     */
    function r(i) {
      const b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
      return Math.log(Math.sqrt(b * b + 1) - b);
    }
    function sinh(n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    }
    function cosh(n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    }
    function tanh(n) {
      return sinh(n) / cosh(n);
    }

    // r₀: Zoom-out factor during ascent.
    const r0 = r(0);

    // w(s): Returns the visible span on the ground, measured in pixels with respect to the
    // initial scale. Assumes an angular field of view of 2 arctan ½ ≈ 53°.
    let w = s => {
      return cosh(r0) / cosh(r0 + rho * s);
    };

    // u(s): Returns the distance along the flight path as projected onto the ground plane,
    // measured in pixels from the world image origin at the initial scale.
    let u = s => {
      return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
    };

    // S: Total length of the flight path, measured in ρ-screenfuls.
    let S = (r(1) - r0) / rho;

    // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
    if (Math.abs(u1) < 0.000001 || !isFinite(S)) {
      // Perform a more or less instantaneous transition if the path is too short.
      if (Math.abs(w0 - w1) < 0.000001) {
        return this.easeTo(options, eventData);
      }
      const k = w1 < w0 ? -1 : 1;
      S = Math.abs(Math.log(w1 / w0)) / rho;
      u = () => {
        return 0;
      };
      w = s => {
        return Math.exp(k * rho * s);
      };
    }
    if ('duration' in options) {
      options.duration = +options.duration;
    } else {
      const V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
      options.duration = 1000 * S / V;
    }
    if (options.maxDuration && options.duration > options.maxDuration) {
      options.duration = 0;
    }
    this.zooming = true;
    this.rotating = startBearing !== bearing;
    this.pitching = pitch !== startPitch;
    this.padding = !tr.isPaddingEqual(padding);
    this.prepareEase(eventData, false);
    this.ease(k => {
      // s: The distance traveled along the flight path, measured in ρ-screenfuls.
      const s = k * S;
      // @ts-ignore
      const easeScale = 1 / w(s);
      tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(easeScale);
      if (this.rotating) {
        tr.bearing = (0, _util.interpolate)(startBearing, bearing, k);
      }
      if (this.pitching) {
        tr.pitch = (0, _util.interpolate)(startPitch, pitch, k);
      }
      if (this.padding) {
        tr.interpolatePadding(startPadding, padding, k);
        // When padding is being applied, Transform#centerPoint is changing continously,
        // thus we need to recalculate offsetPoint every frame
        pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      }
      const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(easeScale));
      tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
      this.fireMoveEvents(eventData);
    }, () => this.afterEase(eventData), options);
    return this;
  }
  fitScreenCoordinates(p0, p1, bearing, options, eventData) {
    return this.fitInternal(
    // @ts-ignore
    this.cameraForBoxAndBearing(this.transform.pointLocation(_point.default.convert(p0)), this.transform.pointLocation(_point.default.convert(p1)), bearing,
    // @ts-ignore
    options), options, eventData);
  }
  stop(allowGestures, easeId) {
    if (this.easeFrameId) {
      this.cancelRenderFrame(this.easeFrameId);
      // @ts-ignore
      delete this.easeFrameId;
      // @ts-ignore
      delete this.onEaseFrame;
    }
    if (this.onEaseEnd) {
      // The _onEaseEnd function might emit events which trigger new
      // animation, which sets a new _onEaseEnd. Ensure we don't delete
      // it unintentionally.
      const onEaseEnd = this.onEaseEnd;
      // @ts-ignore
      delete this.onEaseEnd;
      onEaseEnd.call(this, easeId);
    }
    // if (!allowGestures) {
    //     const handlers = (this: any).handlers;
    //     if (handlers) handlers.stop();
    // }
    return this;
  }
  normalizeBearing(bearing, currentBearing) {
    bearing = (0, _util.wrap)(bearing, -180, 180);
    const diff = Math.abs(bearing - currentBearing);
    if (Math.abs(bearing - 360 - currentBearing) < diff) {
      bearing -= 360;
    }
    if (Math.abs(bearing + 360 - currentBearing) < diff) {
      bearing += 360;
    }
    return bearing;
  }
  normalizeCenter(center) {
    const tr = this.transform;
    if (!tr.renderWorldCopies || tr.lngRange) {
      return;
    }
    const delta = center.lng - tr.center.lng;
    center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;
  }
  fireMoveEvents(eventData) {
    this.emit('move', new _event.Event('move', eventData));
    if (this.zooming) {
      this.emit('zoom', new _event.Event('zoom', eventData));
    }
    if (this.rotating) {
      this.emit('rotate', new _event.Event('rotate', eventData));
    }
    if (this.pitching) {
      this.emit('rotate', new _event.Event('pitch', eventData));
    }
  }
  prepareEase(eventData, noMoveStart = false, currently = {}) {
    this.moving = true;
    if (!noMoveStart && !currently.moving) {
      this.emit('movestart', new _event.Event('movestart', eventData));
    }
    if (this.zooming && !currently.zooming) {
      this.emit('zoomstart', new _event.Event('zoomstart', eventData));
    }
    if (this.rotating && !currently.rotating) {
      this.emit('rotatestart', new _event.Event('rotatestart', eventData));
    }
    if (this.pitching && !currently.pitching) {
      this.emit('pitchstart', new _event.Event('pitchstart', eventData));
    }
  }
  afterEase(eventData, easeId) {
    // if this easing is being stopped to start another easing with
    // the same id then don't fire any events to avoid extra start/stop events
    if (this.easeId && easeId && this.easeId === easeId) {
      return;
    }
    // @ts-ignore
    delete this.easeId;
    const wasZooming = this.zooming;
    const wasRotating = this.rotating;
    const wasPitching = this.pitching;
    this.moving = false;
    this.zooming = false;
    this.rotating = false;
    this.pitching = false;
    this.padding = false;
    if (wasZooming) {
      this.emit('zoomend', new _event.Event('zoomend', eventData));
    }
    if (wasRotating) {
      this.emit('rotateend', new _event.Event('rotateend', eventData));
    }
    if (wasPitching) {
      this.emit('pitchend', new _event.Event('pitchend', eventData));
    }
    this.emit('moveend', new _event.Event('moveend', eventData));
  }
  ease(frame, finish, options) {
    if (options.animate === false || options.duration === 0) {
      frame(1);
      finish();
    } else {
      this.easeStart = (0, _util.now)();
      this.easeOptions = options;
      this.onEaseFrame = frame;
      this.onEaseEnd = finish;
      this.easeFrameId = this.requestRenderFrame(this.renderFrameCallback);
    }
  }
  cameraForBoxAndBearing(p0, p1, bearing, options) {
    const defaultPadding = {
      top: 0,
      bottom: 0,
      right: 0,
      left: 0
    };
    options = merge({
      padding: defaultPadding,
      offset: [0, 0],
      maxZoom: this.transform.maxZoom
    }, options);
    if (typeof options.padding === 'number') {
      const p = options.padding;
      options.padding = {
        top: p,
        bottom: p,
        right: p,
        left: p
      };
    }
    options.padding = merge(defaultPadding, options.padding);
    const tr = this.transform;
    const edgePadding = tr.padding;

    // We want to calculate the upper right and lower left of the box defined by p0 and p1
    // in a coordinate system rotate to match the destination bearing.
    const p0world = tr.project(_lng_lat.default.convert(p0));
    const p1world = tr.project(_lng_lat.default.convert(p1));
    const p0rotated = p0world.rotate(-bearing * Math.PI / 180);
    const p1rotated = p1world.rotate(-bearing * Math.PI / 180);
    const upperRight = new _point.default(Math.max(p0rotated.x, p1rotated.x), Math.max(p0rotated.y, p1rotated.y));
    const lowerLeft = new _point.default(Math.min(p0rotated.x, p1rotated.x), Math.min(p0rotated.y, p1rotated.y));

    // Calculate zoom: consider the original bbox and padding.
    const size = upperRight.sub(lowerLeft);
    const scaleX = (tr.width - (
    // @ts-ignore
    edgePadding.left +
    // @ts-ignore
    edgePadding.right +
    // @ts-ignore
    options.padding.left +
    // @ts-ignore
    options.padding.right)) / size.x;
    const scaleY = (tr.height - (
    // @ts-ignore
    edgePadding.top +
    // @ts-ignore
    edgePadding.bottom +
    // @ts-ignore
    options.padding.top +
    // @ts-ignore
    options.padding.bottom)) / size.y;
    if (scaleY < 0 || scaleX < 0) {
      return;
    }
    const zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);

    // Calculate center: apply the zoom, the configured offset, as well as offset that exists as a result of padding.
    const offset = _point.default.convert(options.offset);
    // @ts-ignore
    const paddingOffsetX = (options.padding.left - options.padding.right) / 2;
    // @ts-ignore
    const paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;
    const offsetAtInitialZoom = new _point.default(offset.x + paddingOffsetX, offset.y + paddingOffsetY);
    const offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));
    const center = tr.unproject(p0world.add(p1world).div(2).sub(offsetAtFinalZoom));
    return {
      center,
      zoom,
      bearing
    };
  }
  fitInternal(calculatedOptions, options, eventData) {
    // cameraForBounds warns + returns undefined if unable to fit:
    if (!calculatedOptions) {
      return this;
    }
    options = merge(calculatedOptions, options);
    // Explictly remove the padding field because, calculatedOptions already accounts for padding by setting zoom and center accordingly.
    delete options.padding;
    // @ts-ignore
    return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);
  }
}
exports.default = Camera;