"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _events = require("./events");
// @ts-ignore

class BlockableMapEventHandler {
  constructor(map) {
    (0, _defineProperty2.default)(this, "map", void 0);
    (0, _defineProperty2.default)(this, "delayContextMenu", void 0);
    (0, _defineProperty2.default)(this, "contextMenuEvent", void 0);
    this.map = map;
  }
  reset() {
    this.delayContextMenu = false;
    // @ts-ignore
    delete this.contextMenuEvent;
  }
  mousemove(e) {
    // mousemove map events should not be fired when interaction handlers (pan, rotate, etc) are active
    this.map.emit(e.type, new _events.MapMouseEvent(e.type, this.map, e));
  }
  mousedown() {
    this.delayContextMenu = true;
  }
  mouseup() {
    this.delayContextMenu = false;
    if (this.contextMenuEvent) {
      this.map.emit('contextmenu', new _events.MapMouseEvent('contextmenu', this.map, this.contextMenuEvent));
      // @ts-ignore
      delete this.contextMenuEvent;
    }
  }
  contextmenu(e) {
    if (this.delayContextMenu) {
      // Mac: contextmenu fired on mousedown; we save it until mouseup for consistency's sake
      this.contextMenuEvent = e;
    } else {
      // Windows: contextmenu fired on mouseup, so fire event now
      this.map.emit(e.type, new _events.MapMouseEvent(e.type, this.map, e));
    }

    // prevent browser context menu when necessary
    if (this.map.listeners('contextmenu')) {
      e.preventDefault();
    }
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
    return true;
  }
  disable() {
    return false;
  }
}
exports.default = BlockableMapEventHandler;