"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _two_touch = _interopRequireDefault(require("./two_touch"));
// @ts-ignore

function isVertical(vector) {
  return Math.abs(vector.y) > Math.abs(vector.x);
}
const ALLOWED_SINGLE_TOUCH_TIME = 100;
class TouchPitchHandler extends _two_touch.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "valid", void 0);
    (0, _defineProperty2.default)(this, "firstMove", void 0);
    (0, _defineProperty2.default)(this, "lastPoints", void 0);
  }
  reset() {
    super.reset();
    this.valid = undefined;
    // @ts-ignore
    delete this.firstMove;
    // @ts-ignore
    delete this.lastPoints;
  }
  start(points) {
    this.lastPoints = points;
    if (isVertical(points[0].sub(points[1]))) {
      // fingers are more horizontal than vertical
      this.valid = false;
    }
  }
  move(points, center, e) {
    const vectorA = points[0].sub(this.lastPoints[0]);
    const vectorB = points[1].sub(this.lastPoints[1]);
    this.valid = this.gestureBeginsVertically(vectorA, vectorB, e.timeStamp);
    if (!this.valid) {
      return;
    }
    this.lastPoints = points;
    this.active = true;
    const yDeltaAverage = (vectorA.y + vectorB.y) / 2;
    const degreesPerPixelMoved = -0.5;
    return {
      pitchDelta: yDeltaAverage * degreesPerPixelMoved
    };
  }
  gestureBeginsVertically(vectorA, vectorB, timeStamp) {
    if (this.valid !== undefined) {
      return this.valid;
    }
    const threshold = 2;
    const movedA = vectorA.mag() >= threshold;
    const movedB = vectorB.mag() >= threshold;

    // neither finger has moved a meaningful amount, wait
    if (!movedA && !movedB) {
      return;
    }

    // One finger has moved and the other has not.
    // If enough time has passed, decide it is not a pitch.
    if (!movedA || !movedB) {
      if (this.firstMove === undefined) {
        this.firstMove = timeStamp;
      }
      if (timeStamp - this.firstMove < ALLOWED_SINGLE_TOUCH_TIME) {
        // still waiting for a movement from the second finger
        return undefined;
      } else {
        return false;
      }
    }
    const isSameDirection = vectorA.y > 0 === vectorB.y > 0;
    return isVertical(vectorA) && isVertical(vectorB) && isSameDirection;
  }
}
exports.default = TouchPitchHandler;