"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _point = _interopRequireDefault(require("../geo/point"));
var _dom = _interopRequireDefault(require("../utils/dom"));
var _blockable_map_event = _interopRequireDefault(require("./blockable_map_event"));
var _box_zoom = _interopRequireDefault(require("./box_zoom"));
var _click_zoom = _interopRequireDefault(require("./click_zoom"));
var _event = require("./events/event");
var _render_event = _interopRequireDefault(require("./events/render_event"));
var _handler_inertia = _interopRequireDefault(require("./handler_inertia"));
var _keyboard = _interopRequireDefault(require("./keyboard"));
var _map_event = _interopRequireDefault(require("./map_event"));
var _mouse = require("./mouse");
var _scroll_zoom = _interopRequireDefault(require("./scroll_zoom"));
var _dblclick_zoom = _interopRequireDefault(require("./shim/dblclick_zoom"));
var _drag_pan = _interopRequireDefault(require("./shim/drag_pan"));
var _drag_rotate = _interopRequireDefault(require("./shim/drag_rotate"));
var _touch_zoom_rotate = _interopRequireDefault(require("./shim/touch_zoom_rotate"));
var _tap_drag_zoom = _interopRequireDefault(require("./tap/tap_drag_zoom"));
var _tap_zoom = _interopRequireDefault(require("./tap/tap_zoom"));
var _touch = require("./touch");
// @ts-ignore
// tslint:disable-next-line: no-submodule-imports

const {
  merge
} = _l7Utils.lodashUtil;
const isMoving = p => p.zoom || p.drag || p.pitch || p.rotate;
function hasChange(result) {
  return result.panDelta && result.panDelta.mag() || result.zoomDelta || result.bearingDelta || result.pitchDelta;
}
class HandlerManager {
  constructor(map, options) {
    (0, _defineProperty2.default)(this, "map", void 0);
    (0, _defineProperty2.default)(this, "el", void 0);
    (0, _defineProperty2.default)(this, "handlers", void 0);
    (0, _defineProperty2.default)(this, "eventsInProgress", void 0);
    (0, _defineProperty2.default)(this, "frameId", void 0);
    (0, _defineProperty2.default)(this, "inertia", void 0);
    (0, _defineProperty2.default)(this, "bearingSnap", void 0);
    (0, _defineProperty2.default)(this, "handlersById", void 0);
    (0, _defineProperty2.default)(this, "updatingCamera", void 0);
    (0, _defineProperty2.default)(this, "changes", void 0);
    (0, _defineProperty2.default)(this, "previousActiveHandlers", void 0);
    (0, _defineProperty2.default)(this, "bearingChanged", void 0);
    (0, _defineProperty2.default)(this, "rotateEnabled", void 0);
    (0, _defineProperty2.default)(this, "pitchEnabled", void 0);
    (0, _defineProperty2.default)(this, "listeners", void 0);
    (0, _defineProperty2.default)(this, "handleWindowEvent", e => {
      this.handleEvent(e, `${e.type}Window`);
    });
    (0, _defineProperty2.default)(this, "handleEvent", (e, eventName) => {
      if (e.type === 'blur') {
        this.stop();
        return;
      }
      this.updatingCamera = true;
      const inputEvent = e.type === 'renderFrame' ? undefined : e;

      /*
       * We don't call e.preventDefault() for any events by default.
       * Handlers are responsible for calling it where necessary.
       */

      const mergedIHandlerResult = {
        needsRenderFrame: false
      };
      const eventsInProgress = {};
      const activeHandlers = {};
      // @ts-ignore
      const mapTouches = e.touches ?
      // @ts-ignore
      this.getMapTouches(e.touches) : undefined;
      const points = mapTouches ? _dom.default.touchPos(this.el, mapTouches) : _dom.default.mousePos(this.el, e);
      for (const {
        handlerName,
        handler,
        allowed
      } of this.handlers) {
        if (!handler.isEnabled()) {
          continue;
        }
        let data;
        if (this.blockedByActive(activeHandlers, allowed, handlerName)) {
          handler.reset();
        } else {
          const handerName = eventName || e.type;
          // @ts-ignore
          if (handler && handler[handerName]) {
            // @ts-ignore
            data = handler[handerName](e, points, mapTouches);
            this.mergeIHandlerResult(mergedIHandlerResult, eventsInProgress, data, handlerName, inputEvent);
            if (data && data.needsRenderFrame) {
              this.triggerRenderFrame();
            }
          }
        }
        // @ts-ignore
        if (data || handler.isActive()) {
          activeHandlers[handlerName] = handler;
        }
      }
      const deactivatedHandlers = {};
      for (const name in this.previousActiveHandlers) {
        if (!activeHandlers[name]) {
          deactivatedHandlers[name] = inputEvent;
        }
      }
      this.previousActiveHandlers = activeHandlers;
      if (Object.keys(deactivatedHandlers).length || hasChange(mergedIHandlerResult)) {
        this.changes.push([mergedIHandlerResult, eventsInProgress, deactivatedHandlers]);
        this.triggerRenderFrame();
      }
      if (Object.keys(activeHandlers).length || hasChange(mergedIHandlerResult)) {
        this.map.stop(true);
      }
      this.updatingCamera = false;
      const {
        cameraAnimation
      } = mergedIHandlerResult;
      if (cameraAnimation) {
        this.inertia.clear();
        this.fireEvents({}, {});
        this.changes = [];
        cameraAnimation(this.map);
      }
    });
    this.map = map;
    this.el = this.map.getCanvasContainer();
    this.handlers = [];
    this.handlersById = {};
    this.changes = [];
    this.inertia = new _handler_inertia.default(map);
    this.bearingSnap = options.bearingSnap;
    this.rotateEnabled = options.rotateEnabled;
    this.pitchEnabled = options.pitchEnabled;
    this.previousActiveHandlers = {};

    // Track whether map is currently moving, to compute start/move/end events
    this.eventsInProgress = {};
    this.addDefaultHandlers(options);
    const el = this.el;
    this.listeners = [];
    // l7 - mini
    this.listeners = [
    // Bind touchstart and touchmove with passive: false because, even though
    // they only fire a map events and therefore could theoretically be
    // passive, binding with passive: true causes iOS not to respect
    // e.preventDefault() in _other_ handlers, even if they are non-passive
    // (see https://bugs.webkit.org/show_bug.cgi?id=184251)
    [el, 'touchstart', {
      passive: false
    }], [el, 'touchmove', {
      passive: false
    }], [el, 'touchend', undefined], [el, 'touchcancel', undefined], [el, 'mousedown', undefined], [el, 'mousemove', undefined], [el, 'mouseup', undefined],
    // Bind window-level event listeners for move and up/end events. In the absence of
    // the pointer capture API, which is not supported by all necessary platforms,
    // window-level event listeners give us the best shot at capturing events that
    // fall outside the map canvas element. Use `{capture: true}` for the move event
    // to prevent map move events from being fired during a drag.
    // @ts-ignore
    [window.document, 'mousemove', {
      capture: true
    }],
    // @ts-ignore
    [window.document, 'mouseup', undefined], [el, 'mouseover', undefined], [el, 'mouseout', undefined], [el, 'dblclick', undefined], [el, 'click', undefined], [el, 'keydown', {
      capture: false
    }], [el, 'keyup', undefined], [el, 'wheel', {
      passive: false
    }], [el, 'contextmenu', undefined],
    // @ts-ignore
    [window, 'blur', undefined]];
    for (const [target, type, listenerOptions] of this.listeners) {
      // @ts-ignore
      _dom.default.addEventListener(target, type,
      // @ts-ignore
      target === window.document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
    }
  }
  destroy() {
    for (const [target, type, listenerOptions] of this.listeners) {
      // @ts-ignore
      _dom.default.removeEventListener(target, type,
      // @ts-ignore
      target === window.document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
    }
  }
  stop() {
    // do nothing if this method was triggered by a gesture update
    if (this.updatingCamera) {
      return;
    }
    for (const {
      handler
    } of this.handlers) {
      handler.reset();
    }
    this.inertia.clear();
    this.fireEvents({}, {});
    this.changes = [];
  }
  isActive() {
    for (const {
      handler
    } of this.handlers) {
      if (handler.isActive()) {
        return true;
      }
    }
    return false;
  }
  isZooming() {
    return !!this.eventsInProgress.zoom || this.map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this.eventsInProgress.rotate;
  }
  isMoving() {
    return Boolean(isMoving(this.eventsInProgress)) || this.isZooming();
  }
  mergeIHandlerResult(mergedIHandlerResult, eventsInProgress, HandlerResult, name, e) {
    if (!HandlerResult) {
      return;
    }
    merge(mergedIHandlerResult, HandlerResult);
    const eventData = {
      handlerName: name,
      originalEvent: HandlerResult.originalEvent || e
    };

    // track which handler changed which camera property
    if (HandlerResult.zoomDelta !== undefined) {
      eventsInProgress.zoom = eventData;
    }
    if (HandlerResult.panDelta !== undefined) {
      eventsInProgress.drag = eventData;
    }
    if (HandlerResult.pitchDelta !== undefined) {
      eventsInProgress.pitch = eventData;
    }
    if (HandlerResult.bearingDelta !== undefined) {
      eventsInProgress.rotate = eventData;
    }
  }
  triggerRenderFrame() {
    if (this.frameId === undefined) {
      this.frameId = this.map.requestRenderFrame(timeStamp => {
        // @ts-ignore
        delete this.frameId;
        this.handleEvent(new _render_event.default('renderFrame', {
          timeStamp
        }));
        this.applyChanges();
      });
    }
  }
  addDefaultHandlers(options) {
    const map = this.map;
    const el = map.getCanvasContainer();
    this.add('mapEvent', new _map_event.default(map, options));
    const boxZoom = map.boxZoom = new _box_zoom.default(map, options);
    this.add('boxZoom', boxZoom);
    const tapZoom = new _tap_zoom.default();
    const clickZoom = new _click_zoom.default();
    map.doubleClickZoom = new _dblclick_zoom.default(clickZoom, tapZoom);
    this.add('tapZoom', tapZoom);
    this.add('clickZoom', clickZoom);
    const tapDragZoom = new _tap_drag_zoom.default();
    this.add('tapDragZoom', tapDragZoom);
    const touchPitch = map.touchPitch = new _touch.TouchPitchHandler();
    this.add('touchPitch', touchPitch);
    const mouseRotate = new _mouse.MouseRotateHandler(options);
    const mousePitch = new _mouse.MousePitchHandler(options);
    map.dragRotate = new _drag_rotate.default(options, mouseRotate, mousePitch);
    this.add('mouseRotate', mouseRotate, ['mousePitch']);
    this.add('mousePitch', mousePitch, ['mouseRotate']);
    const mousePan = new _mouse.MousePanHandler(options);
    const touchPan = new _touch.TouchPanHandler(options);
    map.dragPan = new _drag_pan.default(el, mousePan, touchPan);
    this.add('mousePan', mousePan);
    this.add('touchPan', touchPan, ['touchZoom', 'touchRotate']);
    const touchRotate = new _touch.TouchRotateHandler();
    const touchZoom = new _touch.TouchZoomHandler();
    map.touchZoomRotate = new _touch_zoom_rotate.default(el, touchZoom, touchRotate, tapDragZoom);
    this.add('touchRotate', touchRotate, ['touchPan', 'touchZoom']);
    this.add('touchZoom', touchZoom, ['touchPan', 'touchRotate']);
    const scrollZoom = map.scrollZoom = new _scroll_zoom.default(map, this);
    this.add('scrollZoom', scrollZoom, ['mousePan']);
    const keyboard = map.keyboard = new _keyboard.default();
    this.add('keyboard', keyboard);
    this.add('blockableMapEvent', new _blockable_map_event.default(map));
    for (const name of ['boxZoom', 'doubleClickZoom', 'tapDragZoom', 'touchPitch', 'dragRotate', 'dragPan', 'touchZoomRotate', 'scrollZoom', 'keyboard']) {
      // @ts-ignore
      if (options.interactive && options[name]) {
        // @ts-ignore
        map[name].enable(options[name]);
      }
    }
  }
  add(handlerName, handler, allowed) {
    this.handlers.push({
      handlerName,
      handler,
      allowed
    });
    this.handlersById[handlerName] = handler;
  }
  blockedByActive(activeHandlers, allowed, myName) {
    for (const name in activeHandlers) {
      if (name === myName) {
        continue;
      }
      if (!allowed || allowed.indexOf(name) < 0) {
        return true;
      }
    }
    return false;
  }
  getMapTouches(touches) {
    const mapTouches = [];
    for (const t of touches) {
      const target = t.target;
      if (this.el.contains(target)) {
        mapTouches.push(t);
      }
    }
    return mapTouches;
  }
  applyChanges() {
    const combined = {};
    const combinedEventsInProgress = {};
    const combinedDeactivatedHandlers = {};
    for (const [change, eventsInProgress, deactivatedHandlers] of this.changes) {
      if (change.panDelta) {
        combined.panDelta = (combined.panDelta || new _point.default(0, 0))._add(change.panDelta);
      }
      if (change.zoomDelta) {
        combined.zoomDelta = (combined.zoomDelta || 0) + change.zoomDelta;
      }
      if (change.bearingDelta) {
        combined.bearingDelta = (combined.bearingDelta || 0) + change.bearingDelta;
      }
      if (change.pitchDelta) {
        combined.pitchDelta = (combined.pitchDelta || 0) + change.pitchDelta;
      }
      if (change.around !== undefined) {
        combined.around = change.around;
      }
      if (change.pinchAround !== undefined) {
        combined.pinchAround = change.pinchAround;
      }
      if (change.noInertia) {
        combined.noInertia = change.noInertia;
      }
      merge(combinedEventsInProgress, eventsInProgress);
      merge(combinedDeactivatedHandlers, deactivatedHandlers);
    }
    this.updateMapTransform(combined, combinedEventsInProgress, combinedDeactivatedHandlers);
    this.changes = [];
  }
  updateMapTransform(combinedResult, combinedEventsInProgress, deactivatedHandlers) {
    const map = this.map;
    const tr = map.transform;
    if (!hasChange(combinedResult)) {
      return this.fireEvents(combinedEventsInProgress, deactivatedHandlers);
    }
    const {
      panDelta,
      zoomDelta,
      bearingDelta,
      pitchDelta,
      pinchAround
    } = combinedResult;
    let {
      around
    } = combinedResult;
    if (pinchAround !== undefined) {
      around = pinchAround;
    }

    // stop any ongoing camera animations (easeTo, flyTo)
    map.stop(true);
    around = around || map.transform.centerPoint;
    const loc = tr.pointLocation(panDelta ? around.sub(panDelta) : around);
    if (bearingDelta && this.rotateEnabled) {
      tr.bearing += bearingDelta;
    }
    if (pitchDelta && this.pitchEnabled) {
      tr.pitch += pitchDelta;
    }
    if (zoomDelta) {
      tr.zoom += zoomDelta;
    }
    tr.setLocationAtPoint(loc, around);
    this.map.update();
    if (!combinedResult.noInertia) {
      this.inertia.record(combinedResult);
    }
    this.fireEvents(combinedEventsInProgress, deactivatedHandlers);
  }
  fireEvents(newEventsInProgress, deactivatedHandlers) {
    const wasMoving = isMoving(this.eventsInProgress);
    const nowMoving = isMoving(newEventsInProgress);
    const startEvents = {};
    for (const eventName in newEventsInProgress) {
      if (newEventsInProgress[eventName]) {
        const {
          originalEvent
        } = newEventsInProgress[eventName];
        if (!this.eventsInProgress[eventName]) {
          startEvents[`${eventName}start`] = originalEvent;
        }
        this.eventsInProgress[eventName] = newEventsInProgress[eventName];
      }
    }

    // fire start events only after this.eventsInProgress has been updated
    if (!wasMoving && nowMoving) {
      this.fireEvent('movestart', nowMoving.originalEvent);
    }
    for (const name in startEvents) {
      if (startEvents[name]) {
        this.fireEvent(name, startEvents[name]);
      }
    }
    if (newEventsInProgress.rotate) {
      this.bearingChanged = true;
    }
    if (nowMoving) {
      this.fireEvent('move', nowMoving.originalEvent);
    }
    for (const eventName in newEventsInProgress) {
      if (newEventsInProgress[eventName]) {
        const {
          originalEvent
        } = newEventsInProgress[eventName];
        this.fireEvent(eventName, originalEvent);
      }
    }
    const endEvents = {};
    let originalEndEvent;
    for (const eventName in this.eventsInProgress) {
      if (this.eventsInProgress[eventName]) {
        const {
          handlerName,
          originalEvent
        } = this.eventsInProgress[eventName];
        if (!this.handlersById[handlerName].isActive()) {
          delete this.eventsInProgress[eventName];
          originalEndEvent = deactivatedHandlers[handlerName] || originalEvent;
          endEvents[`${eventName}end`] = originalEndEvent;
        }
      }
    }
    for (const name in endEvents) {
      if (endEvents[name]) {
        this.fireEvent(name, endEvents[name]);
      }
    }
    const stillMoving = isMoving(this.eventsInProgress);
    if ((wasMoving || nowMoving) && !stillMoving) {
      this.updatingCamera = true;
      const inertialEase = this.inertia.onMoveEnd(this.map.dragPan.inertiaOptions);
      const shouldSnapToNorth = bearing => bearing !== 0 && -this.bearingSnap < bearing && bearing < this.bearingSnap;
      if (inertialEase) {
        if (shouldSnapToNorth(inertialEase.bearing || this.map.getBearing())) {
          inertialEase.bearing = 0;
        }
        this.map.easeTo(inertialEase, {
          originalEvent: originalEndEvent
        });
      } else {
        this.map.emit('moveend', new _event.Event('moveend', {
          originalEvent: originalEndEvent
        }));
        if (shouldSnapToNorth(this.map.getBearing())) {
          this.map.resetNorth();
        }
      }
      this.bearingChanged = false;
      this.updatingCamera = false;
    }
  }
  fireEvent(type, e) {
    this.map.emit(type, new _event.Event(type, e ? {
      originalEvent: e
    } : {}));
  }
}
var _default = exports.default = HandlerManager;