"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MAX_TOUCH_TIME = exports.MAX_TAP_INTERVAL = exports.MAX_DIST = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _point = _interopRequireDefault(require("../../geo/point"));
var _handler_util = require("../handler_util");
// @ts-ignore

function getCentroid(points) {
  const sum = new _point.default(0, 0);
  for (const point of points) {
    sum._add(point);
  }
  // @ts-ignore
  return sum.div(points.length);
}
const MAX_TAP_INTERVAL = exports.MAX_TAP_INTERVAL = 500;
const MAX_TOUCH_TIME = exports.MAX_TOUCH_TIME = 500;
const MAX_DIST = exports.MAX_DIST = 30;
class SingleTapRecognizer {
  constructor(options) {
    (0, _defineProperty2.default)(this, "numTouches", void 0);
    (0, _defineProperty2.default)(this, "centroid", void 0);
    (0, _defineProperty2.default)(this, "startTime", void 0);
    (0, _defineProperty2.default)(this, "aborted", void 0);
    (0, _defineProperty2.default)(this, "touches", void 0);
    this.reset();
    this.numTouches = options.numTouches;
  }
  reset() {
    // @ts-ignore
    delete this.centroid;
    // @ts-ignore
    delete this.startTime;
    // @ts-ignore
    delete this.touches;
    this.aborted = false;
  }
  touchstart(e, points, mapTouches) {
    if (this.centroid || mapTouches.length > this.numTouches) {
      this.aborted = true;
    }
    if (this.aborted) {
      return;
    }
    if (this.startTime === undefined) {
      this.startTime = e.timeStamp;
    }
    if (mapTouches.length === this.numTouches) {
      this.centroid = getCentroid(points);
      this.touches = (0, _handler_util.indexTouches)(mapTouches, points);
    }
  }
  touchmove(e, points, mapTouches) {
    if (this.aborted || !this.centroid) {
      return;
    }
    const newTouches = (0, _handler_util.indexTouches)(mapTouches, points);
    for (const id in this.touches) {
      if (this.touches[id]) {
        const prevPos = this.touches[id];
        const pos = newTouches[id];
        if (!pos || pos.dist(prevPos) > MAX_DIST) {
          this.aborted = true;
        }
      }
    }
  }
  touchend(e, points, mapTouches) {
    if (!this.centroid || e.timeStamp - this.startTime > MAX_TOUCH_TIME) {
      this.aborted = true;
    }
    if (mapTouches.length === 0) {
      const centroid = !this.aborted && this.centroid;
      this.reset();
      if (centroid) {
        return centroid;
      }
    }
  }
}
exports.default = SingleTapRecognizer;